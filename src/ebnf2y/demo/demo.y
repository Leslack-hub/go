%{

//TODO Put your favorite license here
		
// yacc source generated by ebnf2y[1]
// at 2025-01-23 11:42:16.280738 +0800 CST m=+0.001176251
//
//  $ ebnf2y -start Expression -o demo.y demo.ebnf
//
// CAUTION: If this file is a Go source file (*.go), it was generated
// automatically by '$ go tool yacc' from a *.y file - DO NOT EDIT in that case!
// 
//   [1]: http://modernc.org/ebnf2y

package main //TODO real package name

//TODO required only be the demo _dump function
import (
	"bytes"
	"fmt"
	"strings"

	"modernc.org/strutil"
)

%}

%union {
	item interface{} //TODO insert real field(s)
}

%token	AND
%token	ANDNOT
%token	BOOLEAN
%token	FLOAT
%token	IDENTIFIER
%token	IMAGINARY
%token	INTEGER
%token	LSH
%token	RSH
%token	STR

%type	<item> 	/*TODO real type(s), if/where applicable */
	AND
	ANDNOT
	BOOLEAN
	FLOAT
	IDENTIFIER
	IMAGINARY
	INTEGER
	LSH
	RSH
	STR

%type	<item> 	/*TODO real type(s), if/where applicable */
	Expression
	Expression1
	Expression11
	ExpressionList
	ExpressionList1
	Factor
	Factor1
	Factor11
	Literal
	Operand
	Operand1
	QualifiedIdent
	QualifiedIdent1
	Start
	Term
	Term1
	Term11

/*TODO %left, %right, ... declarations */

%start Start

%%

Expression:
	Term Expression1
	{
		$$ = []Expression{$1, $2} //TODO 1
	}

Expression1:
	/* EMPTY */
	{
		$$ = []Expression1(nil) //TODO 2
	}
|	Expression1 Expression11 Term
	{
		$$ = append($1.([]Expression1), $2, $3) //TODO 3
	}

Expression11:
	'^'
	{
		$$ = "^" //TODO 4
	}
|	'|'
	{
		$$ = "|" //TODO 5
	}
|	'-'
	{
		$$ = "-" //TODO 6
	}
|	'+'
	{
		$$ = "+" //TODO 7
	}

ExpressionList:
	Expression ExpressionList1
	{
		$$ = []ExpressionList{$1, $2} //TODO 8
	}

ExpressionList1:
	/* EMPTY */
	{
		$$ = []ExpressionList1(nil) //TODO 9
	}
|	ExpressionList1 ',' Expression
	{
		$$ = append($1.([]ExpressionList1), ",", $3) //TODO 10
	}

Factor:
	Factor1 Operand
	{
		$$ = []Factor{$1, $2} //TODO 11
	}

Factor1:
	/* EMPTY */
	{
		$$ = nil //TODO 12
	}
|	Factor11
	{
		$$ = $1 //TODO 13
	}

Factor11:
	'^'
	{
		$$ = "^" //TODO 14
	}
|	'!'
	{
		$$ = "!" //TODO 15
	}
|	'-'
	{
		$$ = "-" //TODO 16
	}
|	'+'
	{
		$$ = "+" //TODO 17
	}

Literal:
	BOOLEAN
	{
		$$ = $1 //TODO 18
	}
|	FLOAT
	{
		$$ = $1 //TODO 19
	}
|	QualifiedIdent
	{
		$$ = $1 //TODO 20
	}
|	IMAGINARY
	{
		$$ = $1 //TODO 21
	}
|	INTEGER
	{
		$$ = $1 //TODO 22
	}
|	STR
	{
		$$ = $1 //TODO 23
	}

Operand:
	Literal
	{
		$$ = $1 //TODO 24
	}
|	QualifiedIdent '(' Operand1 ')'
	{
		$$ = []Operand{$1, "(", $3, ")"} //TODO 25
	}
|	'(' Expression ')'
	{
		$$ = []Operand{"(", $2, ")"} //TODO 26
	}

Operand1:
	/* EMPTY */
	{
		$$ = nil //TODO 27
	}
|	ExpressionList
	{
		$$ = $1 //TODO 28
	}

QualifiedIdent:
	IDENTIFIER QualifiedIdent1
	{
		$$ = []QualifiedIdent{$1, $2} //TODO 29
	}

QualifiedIdent1:
	/* EMPTY */
	{
		$$ = nil //TODO 30
	}
|	'.' IDENTIFIER
	{
		$$ = []QualifiedIdent1{".", $2} //TODO 31
	}

Start:
	Expression
	{
		_parserResult = $1 //TODO 32
	}

Term:
	Factor Term1
	{
		$$ = []Term{$1, $2} //TODO 33
	}

Term1:
	/* EMPTY */
	{
		$$ = []Term1(nil) //TODO 34
	}
|	Term1 Term11 Factor
	{
		$$ = append($1.([]Term1), $2, $3) //TODO 35
	}

Term11:
	ANDNOT
	{
		$$ = $1 //TODO 36
	}
|	'&'
	{
		$$ = "&" //TODO 37
	}
|	LSH
	{
		$$ = $1 //TODO 38
	}
|	RSH
	{
		$$ = $1 //TODO 39
	}
|	'%'
	{
		$$ = "%" //TODO 40
	}
|	'/'
	{
		$$ = "/" //TODO 41
	}
|	'*'
	{
		$$ = "*" //TODO 42
	}
|	AND
	{
		$$ = "&&" //TODO 43
	}

%%

//TODO remove demo stuff below

var _parserResult interface{}

type (
	Expression interface{}
	Expression1 interface{}
	Expression11 interface{}
	ExpressionList interface{}
	ExpressionList1 interface{}
	Factor interface{}
	Factor1 interface{}
	Factor11 interface{}
	Literal interface{}
	Operand interface{}
	Operand1 interface{}
	QualifiedIdent interface{}
	QualifiedIdent1 interface{}
	Start interface{}
	Term interface{}
	Term1 interface{}
	Term11 interface{}
)
	
func _dump() {
	s := fmt.Sprintf("%#v", _parserResult)
	s = strings.Replace(s, "%", "%%", -1)
	s = strings.Replace(s, "{", "{%i\n", -1)
	s = strings.Replace(s, "}", "%u\n}", -1)
	s = strings.Replace(s, ", ", ",\n", -1)
	var buf bytes.Buffer
	strutil.IndentFormatter(&buf, ". ").Format(s)
	buf.WriteString("\n")
	a := strings.Split(buf.String(), "\n")
	for _, v := range a {
		if strings.HasSuffix(v, "(nil)") || strings.HasSuffix(v, "(nil),") {
			continue
		}
	
		fmt.Println(v)
	}
}

// End of demo stuff
